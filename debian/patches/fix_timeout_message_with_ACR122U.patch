Description: Timeout message from ACR122U is deemed too short
Forwarded: http://www.libnfc.org/community/topic/1279/timeout-message-from-acr122u-is-deemed-too-short/
Author: Steinar H. Gunderson <sesse@debian.org>
Bug-Debian: http://bugs.debian.org/759355
Last-Update: 2014-09-06

diff --git a/libnfc/drivers/acr122_usb.c b/libnfc/drivers/acr122_usb.c
index a6392e8..377e056 100644
--- a/libnfc/drivers/acr122_usb.c
+++ b/libnfc/drivers/acr122_usb.c
@@ -604,6 +604,7 @@ read:
 
   uint8_t attempted_response = RDR_to_PC_DataBlock;
   size_t len;
+  int error, status;
 
   if (res == NFC_ETIMEOUT) {
     if (DRIVER_DATA(pnd)->abort_flag) {
@@ -615,7 +616,7 @@ read:
       goto read;
     }
   }
-  if (res < 12) {
+  if (res < 10) {
     log_put(LOG_GROUP, LOG_CATEGORY, NFC_LOG_PRIORITY_ERROR, "%s", "Invalid RDR_to_PC_DataBlock frame");
     // try to interrupt current device state
     acr122_usb_ack(pnd);
@@ -630,6 +631,16 @@ read:
   offset++;
 
   len = abtRxBuf[offset++];
+  status = abtRxBuf[7];
+  error = abtRxBuf[8];
+  if (len == 0 && error == 0xFE) {  // ICC_MUTE; XXX check for more errors
+    // Do not check status; my ACR122U seemingly has status=0 in this case,
+    // even though the spec says it should have had bmCommandStatus=1
+    // and bmICCStatus=1.
+    log_put(LOG_GROUP, LOG_CATEGORY, NFC_LOG_PRIORITY_DEBUG, "%s", "Command timed out");
+    pnd->last_error = NFC_ETIMEOUT;
+    return pnd->last_error;
+  }
   if (!((len > 1) && (abtRxBuf[10] == 0xd5))) { // In case we didn't get an immediate answer:
     if (len != 2) {
       log_put(LOG_GROUP, LOG_CATEGORY, NFC_LOG_PRIORITY_ERROR, "%s", "Wrong reply");
@@ -658,7 +669,7 @@ read:
         goto read; // FIXME May cause some trouble on Touchatag, right ?
       }
     }
-    if (res < 12) {
+    if (res < 10) {
       // try to interrupt current device state
       acr122_usb_ack(pnd);
       pnd->last_error = NFC_EIO;
@@ -697,7 +708,7 @@ read:
 
   // Skip CCID remaining bytes
   offset += 2; // bSlot and bSeq are not used
-  offset += 2; // XXX bStatus and bError should maybe checked ?
+  offset += 2; // bError is partially checked above
   offset += 1; // bRFU should be 0x00
 
   // TFI + PD0 (CC+1)
